---
layout: post
title: Our Static Analysis Metrics and Features
categories: []
tags: []
status: publish
type: post
published: true
meta: {}
excerpt_separator: <!--more-->
---
<p>If you've seen <a href="/2016/09/01/score-distributions-in-osx-win10-and-linux.html">our post</a> about the score distributions in OSX, Linux, and Windows 10 base installs, your first question is probably about what factors go into computing those scores.<!--more--> &nbsp;This post will provide some high level understanding of what factors we consider for those static analysis scores. &nbsp;</p><p>The main question we're trying to find the answer to is, "How difficult is it for an attacker to find a new exploit for this software?". &nbsp;Attackers have limited resources, and just like anyone else, they don't like to waste their time doing something the hard way if an easier path is available. &nbsp;They have tricks and heuristics they use to assess the relative difficulty to exploit software, so that they can focus on the easy targets and low hanging fruit. &nbsp;Mudge has had a long career of doing just that (legally, and for research purposes), so he's developed his own personal toolkit of measurements to take when assessing software risk. &nbsp;By consulting with other luminaries of the security field who have extensive exploit development experience, we've been able to build up the list of static analysis metrics and features which we currently assess.</p><p>There are three main categories of static analysis features that we look at for a software binary:&nbsp;</p><ul><li>Complexity&nbsp;</li><li>Application Armoring</li><li>Developer Hygiene</li></ul><p>For each of these, I'm going to list some of the main features and why these are important to have when estimating software risk. &nbsp;</p><h2>Complexity</h2><p>First up, why does complexity matter? &nbsp;Because more complex code is harder to review and maintain, and is more likely to contain bugs. &nbsp;This is why <a href="http://lars-lab.jpl.nasa.gov/JPL_Coding_Standard_C.pdf">NASA/JPL</a> put limits on things like function size for code that's going into critical systems. &nbsp;</p><p>We look at more complex measurements like cyclomatic complexity, but my favorite features are the simpler ones:&nbsp;</p><ul><li>Code Size</li><li>Number of Conditional Branches</li><li>Size &amp; Number of Stack Adjusts</li><li>Function Size</li></ul><p>Measurements like code size, number of branches and stack adjusts have a roughly lognormal distribution. &nbsp;In general, we expect the density of branches to be constant. &nbsp;That is, as code size increases, the counts for branches or stack adjusts should increase correspondingly. &nbsp;If the number of branches is highly disproportionate compared to the code size, giving the code a high branch density,&nbsp;that indicates a high level of complexity (and thus a higher level of risk). &nbsp;</p><h2>Application Armoring</h2><p>Modern compilers, linkers, and loaders come with lots of nifty safety features, but they won't do you any good if the software doesn't have them enabled. &nbsp;These features are to software what airbags and seatbelts are to cars: things that are known and proven to improve safety, and whose use should be established by now as industry-standard. &nbsp;If your car doesn't have airbags, you're entitled to know that before you buy it. &nbsp;</p><p>We've broken these features out by which part of the software lifecycle is responsible for implementing it.</p><ul><li>Compiler<ul style="margin-left:40px"><li>Stack Guards</li><li>Function Fortification</li><li>Control Flow Integrity (CFI/CPI)</li><li>...</li></ul></li><li>Linker<ul style="margin-left:40px"><li>Address Space Layout Randomiziation (ASLR)</li><li>Segment and Section ordering</li><li>...</li></ul></li><li>Loader<ul style="margin-left:40px"><li>Section, Segment execution chars</li><li>Allocations and access</li><li>Code signing and/or verification</li><li>...</li></ul></li></ul><h2>Developer Hygiene</h2><p>There are things we can learn about a developer's security skill and knowledge based on what functions are used in the code they write. &nbsp;Some functions, like strcpy and strcat, are hard to use without introducing vulnerabilities. &nbsp;Less risky functions like strncpy and strncat are better, but still easy to use incorrectly. &nbsp;On the other hand, there are functions like strlcpy and strlcat, which were written with security considerations in mind, and which are difficult to use <em>incorrectly</em>. &nbsp;Finally, there are a few functions, such as system or gets, that should never be used in commercial code, because they simply pose too great of a security risk. &nbsp;</p><p>We call these four categories of fuctions "bad", "risky", "good", and "ick". &nbsp;We have about 500 POSIX and ANSI functions that fall into these categories, and by looking at the frequency, count, and consistency of the function categories used we can learn a lot about the developer practices of a particular software vendor. &nbsp;</p><p>Â </p>
